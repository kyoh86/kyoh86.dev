<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tech on kyoh86.work</title>
    <link>https://kyoh86.work/categories/tech/</link>
    <description>Recent content in Tech on kyoh86.work</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Sun, 25 Mar 2018 12:05:01 +0900</lastBuildDate>
    
	<atom:link href="https://kyoh86.work/categories/tech/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>golangのstrings.TrimLeftはイケてない</title>
      <link>https://kyoh86.work/posts/2018-03-25_12-05-01/</link>
      <pubDate>Sun, 25 Mar 2018 12:05:01 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2018-03-25_12-05-01/</guid>
      <description>ツイートしたりもしたけど、やはり気になるのでつらつらとポエムる。
strings.TrimLeftわかりづらくね？ golangのstrings.TrimLeft(Right)とstrings.TrimPrefix(Suffix)の関係が嫌い。
TrimLeftの方は概念的にはTrimLeft(s string, cutset set&amp;lt;rune&amp;gt;)のはずなのに、TrimLeft(s string, cutset string)となってる。 結果、型としてはTrimLeft(string, string)とTrimPrefix(string, string)は見分けがつかない。 Prefixの存在を知らないとTrimLeft(&amp;quot;abc-back&amp;quot;, &amp;quot;abc-&amp;quot;)とか書かれてたときに想像する結果が二通りに分岐してしまう。 正解は&amp;quot;k&amp;quot;なわけだけど、&amp;quot;back&amp;quot;かな、と思っちゃう場合もある。というかgolangを2年触ってる僕だってそう思う。
すべての関数は型で中身が想像できるべきだ！なんて1ミリも思わないけど、こればっかりはわかりづらすぎないか？
じゃあどうするか golangにはset&amp;lt;T&amp;gt;がない（と言うかジェネリクスないし）わけだけど、代わりに何使うか。 形式的にはmap[T]struct{}とか定番だけど、
strings.TrimLeft(&amp;quot;abcback&amp;quot;, map[rune]struct{}{ &#39;a&#39;:struct{}{}, &#39;b&#39;:struct{}{}, &#39;c&#39;:struct{}{} })  悍ましくて書きたくない。
結局、arrayじゃね？ということで、strings.TrimLeft(string, []rune)としてほしい。 結局stringと似た何かなんだけど、配列はシーケンシャルであると同時に集合としてのニュアンスを（stringよりは）持つと思うんだよね。
2に期待 golang 2でstrings.TrimLeft(string, []rune)への変更が為されないかと密かに期待している。 RFC書きたいけど、議論が紛糾しそうで、そんな場に英語で参戦する勇気が出ない。</description>
    </item>
    
    <item>
      <title>【作りたいもの】golangでLCSVパーサ</title>
      <link>https://kyoh86.work/posts/2018-03-03_11-37-00/</link>
      <pubDate>Sat, 03 Mar 2018 11:37:00 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2018-03-03_11-37-00/</guid>
      <description>メモ
LCSV (Labeled-CSV) のパーサがほしい できればstruct tagのパースできるやつ
使い方は2種類あって、CSVパーサみたいに各行パースするやつと、JSON的にワンライナーの文字列をパースするやつ。
イメージ（csvと同じ感じで） values := `name: John, country: US, sex: male name: Hana, country: JP, sex: female name: Kim, country: CH` var datum map[string]string var err error reader := lcsv.NewReader(strings.NewReader(values)) for err == nil { datum, err = reader.Read() fmt.Println(datum) } /* Output: map[name:John country:US sex:male] map[name:Hana country:JP sex:female] map[name:Kim country:CH] */  イメージ（jsonな使い方） GoのStruct Tagは、tagName:&amp;quot;HOST_NAME,required,default=example.com&amp;quot;みたいな書かれ方しがち。 tagName をキーに HOST_NAME,required,default=example.com はカンタンに取得できるけど、 中身は各々勝手にルール決めてパースしてる感じ。 でも要はこれLCSVだよねと思うので、&amp;rdquo;クォーテーションできない(Unquoted)&amp;ldquo;、&amp;rdquo;値とラベルの区切り文字が= (LabelSeparator(&#39;=&#39;))とかオプション指定できれば、json.Decoderみたいにやれそう。
var key string var options map[string]string tagValue := `required,default=example.</description>
    </item>
    
    <item>
      <title>Goの俺的scaffoldはこれだ！2017年版</title>
      <link>https://kyoh86.work/posts/2017-12-10_13-13-49/</link>
      <pubDate>Sun, 10 Dec 2017 13:13:49 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2017-12-10_13-13-49/</guid>
      <description>Boom Boom Hello, gophers! Go書いてるかい！
tl;dr 今年も色々、汚物に似た何かをGitHub上に吐き散らかしてきましたが、 来年はもうちょっとキレイな汚物にしようと考え、自分なりに Goで何か作り始めるならここがスタート という物をまとめてみようと思います。
実物 go-initというのを作って運用してます。 中には init.sh が入ってるので、 init.sh ${OWNER} ${NAME} とかすると、 github.com/${OWNER}/${NAME} で運用する前提のディレクトリが出来上がるので、 git init とかして遊ぶといいと思います。 本当はこいつをscaffoldingツールとして仕上げてこの記事を書きたかったんですが、時間切れです。 yeomanでいいじゃん
動機づけ 2017年私的プロジェクト振り返り この2017年、なんやかんや自分なりに色々開発してきて、あれがねえな、これもねえなと思うたびにshell書く代わりぐらいのテンションでgolang書いてきました。
今年メンテしていた自分のリポジトリを雑に振り返ってみると…
 ask  CLIでダイアログだすやーつ。Y/NとかStringとか取れちゃう。嬉しい！ 何番煎じだよ  deject  ローカルリポジトリ管理する君。dog fooding しちゃいるものの、将来性が見えない。 何番煎じｄ  git-branches  git-branch --list 見にくいよ、fzfとかと繋げた時に見やすいの作ろ、と思ったやつ git-for-each-refでいいじゃん  git-prompt  tmuxとか、zshのプロンプトにさ、gitの情報出したいじゃん zshのvcs_infoはさ、スゲーはえーけど、情報足んないじゃん shellでやってもいいけどさ、重いじゃん そうだ、goでやろう。 結構速いよ！（当社比）  git-vertag  segverタグ管理したいけど、npm 。俺のローカルに node がいくつ入ってると思ってるんだ。 何番線  go-spdx  SPDX Licenses（MIT+APSL-1.</description>
    </item>
    
    <item>
      <title>GitHubでセマンティックバージョニングを運用する</title>
      <link>https://kyoh86.work/posts/2017-12-08_00-00-21/</link>
      <pubDate>Fri, 08 Dec 2017 00:00:21 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2017-12-08_00-00-21/</guid>
      <description>tl;dr ちょうど dep (golang用のvendoringツール）を使っている中で、妙なバージョン運用をしているリポジトリに悩まされたので、 いまさらとは思いつつも「GitHubでバージョン管理するならこうだよね」ということをまとめてみました。
Semantics Versioning バージョン番号自体の運用方法については、割と大きなスタンダードがすでにあって、Semantics Versioning(以下semver)がよく使われています。 意外と細かいところで悩まされることも多いので、一度文書には目を通しておいたほうがいいでしょう。英語が難しいという人には日本語の文書も公開されています。
GitHubでの運用 GitHubでこのsemverで運用しようと思った場合、やりかたは色々あるとは思いますが、基本はTagsとブランチの運用になるでしょう。　先の文書に示されたスタンダードと、いくつかsemver関連のツールを触ってみた感じ、次のような運用が良さそうです。
ブランチ  masterブランチは、最新の 安定した バージョン
 バージョニングなんてしらん！というツールやユーザーのためには、masterは安定していることが大切  メジャーバージョンごとにブランチ（以下メジャーブランチとする）を用意する
 過去のメジャーバージョンにもメンテの可能性が当然ある 破壊的変更を企んだ瞬間、新しいメジャーブランチを用意する  masterは安定していることが大切（大切なことなのでｒｙ）  昔懐かしいjQueryとか、1.xと2.xの共存期間が長かったですね。 ~python2?え？~  メジャーブランチの名は v1.x の様に、 vメジャーバージョン番号 + .x(固定文字列) とする
 一部のツールは、タグもブランチも一絡げに捉えようとする &amp;ldquo;ブランチ&amp;rdquo; はあくまで開発が行われる場所なので、単一のバージョンを指している &amp;ldquo;タグ&amp;rdquo; とは命名規則を分けたほうがいい semverに詳しくない人にとっては、 v1 ブランチと v1.0.0 タグの両方がある世界は混乱するだけ  .x がどの程度効くかは不明だけど    タグ  作業ブランチでは打たず、メジャーブランチのコミットに対して打つ
 squash mergeなんかされて、対象のコミットがない、みたいな話もちょっと悲しい  命名はsemverの仕様に則る（大事）
 例：1.0.0-alpha &amp;lt; 1.0.0-alpha.1 &amp;lt; 1.0.0-alpha.beta &amp;lt; 1.</description>
    </item>
    
    <item>
      <title>$GOPATH/binにいるバイナリ群の出自を探る方法</title>
      <link>https://kyoh86.work/posts/2017-08-29_10-55-31/</link>
      <pubDate>Tue, 29 Aug 2017 10:55:31 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2017-08-29_10-55-31/</guid>
      <description> Goを使っていると、ある日突然に日頃使っていたコマンドが全く違う何かに置き換えられていたりして、驚くことがあります。 $GOPATH/bin の下に色々入ってはいるものの、どこの誰かは名前だけではわかりません。
結論 シェルスクリプト go list　を使って、インストールパッケージパス一覧を出してみます。
go list -f &amp;quot;{{if eq \&amp;quot;${GOPATH}/bin/\&amp;quot; (printf \&amp;quot;%.$((${#GOPATH}+5))s\&amp;quot; .Target)}}{{.Target}},{{.ImportPath}}{{end}}&amp;quot; all  結果サンプル パス見てみると、 vendor とか、 examples とか、ちらほらと治安悪いですね。 examples/.../server は鬼畜の所業としか思えないですね。（またgo-swaggerか…）
/Users/user/go/bin/toml-test-decoder,github.com/BurntSushi/toml/cmd/toml-test-decoder /Users/user/go/bin/toml-test-encoder,github.com/BurntSushi/toml/cmd/toml-test-encoder /Users/user/go/bin/tomlv,github.com/BurntSushi/toml/cmd/tomlv /Users/user/go/bin/go-symbols,github.com/acroca/go-symbols /Users/user/go/bin/gometalinter,github.com/alecthomas/gometalinter /Users/user/go/bin/codegen,github.com/alecthomas/gometalinter/vendor/github.com/nicksnyder/go-i18n/i18n/language/codegen /Users/user/go/bin/embedi18n,github.com/alecthomas/gometalinter/vendor/gopkg.in/alecthomas/kingpin.v3-unstable/cmd/embedi18n /Users/user/go/bin/genvalues,github.com/alecthomas/gometalinter/vendor/gopkg.in/alecthomas/kingpin.v3-unstable/cmd/genvalues /Users/user/go/bin/gotests,github.com/cweill/gotests/gotests /Users/user/go/bin/gomodifytags,github.com/fatih/gomodifytags /Users/user/go/bin/motion,github.com/fatih/motion /Users/user/go/bin/swagger,github.com/go-swagger/go-swagger/cmd/swagger /Users/user/go/bin/server,github.com/go-swagger/go-swagger/examples/2.0/petstore/server /Users/user/go/bin/petstore-server,github.com/go-swagger/go-swagger/examples/generated/cmd/petstore-server /Users/user/go/bin/countdown-server,github.com/go-swagger/go-swagger/examples/stream-server/cmd/countdown-server /Users/user/go/bin/agg,github.com/go-swagger/go-swagger/vendor/github.com/kr/text/cmd/agg /Users/user/go/bin/mc,github.com/go-swagger/go-swagger/vendor/github.com/kr/text/mc /Users/user/go/bin/cmd,github.com/go-swagger/go-swagger/vendor/github.com/pelletier/go-toml/cmd /Users/user/go/bin/tomljson,github.com/go-swagger/go-swagger/vendor/github.com/pelletier/go-toml/cmd/tomljson /Users/user/go/bin/tomll,github.com/go-swagger/go-swagger/vendor/github.com/pelletier/go-toml/cmd/tomll  解説 追記予定
余談 server という python -m SimpleServer をちょっと拡張しただけのシェルを自作で使っていたのですが、いつのまにか使えなくなってしまい、 which server としてみたところ、 ~/go/bin/server が返ってきてなんじゃこりゃと思ったり…割と怖い話。
追記予定  package mainを迂闊に書くべきじゃない sampleならsampleのタグを入れるといいかも？ // +build sample その辺ガイドライン的なものは無いのか $PATHに$GOPATH/binを入れるべきではないかもしれない  </description>
    </item>
    
    <item>
      <title>Visual Studio Codeでバックスペースに悩まされたら</title>
      <link>https://kyoh86.work/posts/2017-06-20_19-42-46/</link>
      <pubDate>Tue, 20 Jun 2017 19:42:46 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2017-06-20_19-42-46/</guid>
      <description>TL;DR  VSCodeで日本語入力マジ鬼門 VSCode側では対応予定ないみたい pre-commit hookでもって、せめてコードには残らないようにしてやろう  対象読者 or 前提条件 or 環境 VSCodeで、バックスペースの混入に悩まされている人
さらばATOM 最近ATOMのgoプラグインの開発が滞ってる感があったので、Visual Studio Codeへ乗り換え中です。 ところがどっこい、罠がありました。
VSCodeの日本語入力問題 最近Slackでも問題になった「Mac・IME・Chromiumの組み合わせでバックスペースがゴミとして入力されちゃう問題」が、Visual Studio Codeでも一部影響を受けているようです。 Markdownなどを書いていると、日本語の合間合間に \b（backspace;0x08) が入ってしまいます。
https://github.com/Microsoft/vscode/issues/24981 https://bugs.chromium.org/p/chromium/issues/detail?id=714771
特段の対応予定は無いみたい VSCode的には、Chromiumの最新版が来るのを待つらしい。 それはエディタとしてどうなの。
https://github.com/Microsoft/vscode/issues/24981
だからvimを使えと
ATOMは？ Electronといやあ、Atomはどうなんだよと思ったら、Electronのバージョンが古いために問題になってないみたい。 （現時点での最新は1.6.x)
それはそれでどうなんだ…
いくらなんでもCommitされるのは困る 編集時に意図しない文字が紛れ込むのは１億歩くらいゆずって エディタではなくクソを吐く何かとして 認めてやるとして、いくらなんでもそれがcommitされてしまうのはあまりにもダサいので、pre-commit hook でなんとかしようと思います。
必要なもの  ggrep(gnu-grep)  brew install grep とかしましょう
やるべきこと .git/hooks/pre-commit に、以下コマンドを追加（または新規作成）します。
! git diff --cached --name-only | xargs -n1 ggrep -Hne $&#39;\b&#39;  .git/hooks/pre-commit に実行権限を付与するのを忘れないように。
参考情報 pre-commit hook の使い方</description>
    </item>
    
    <item>
      <title>golangのループ変数の使い方をチェックするlinter作ってみた</title>
      <link>https://kyoh86.work/posts/2017-04-11_06-48-23/</link>
      <pubDate>Tue, 11 Apr 2017 06:48:23 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2017-04-11_06-48-23/</guid>
      <description>動機 golangでforループを回すと、中でうっかりクロージャやリファレンスを取れません。
package example import &amp;quot;fmt&amp;quot; func readme() { values := []string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;} var funcs []func() for _, val := range values { funcs = append(funcs, func() { fmt.Println(val) }) } for _, f := range funcs { f() } /*output: c c c */ var copies []*string for _, val := range values { copies = append(copies, &amp;amp;val) } /*(in copies) &amp;amp;&amp;quot;c&amp;quot; &amp;amp;&amp;quot;c&amp;quot; &amp;amp;&amp;quot;c&amp;quot; */ }  意外と気づきにくいバグの元になってプログラマは容易に死にます。 一応一部のケースは go vet でも検出できますが、万能ではありません。（なぜか go func(){ }() だけは気をつけてくれる)</description>
    </item>
    
    <item>
      <title>今更ながらJSON Schema Core draft 4.0を日本語訳してみた</title>
      <link>https://kyoh86.work/posts/2017-01-22_23-02-52/</link>
      <pubDate>Sun, 22 Jan 2017 23:02:52 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2017-01-22_23-02-52/</guid>
      <description>JSON SchemaのRFCを読むのが苦痛すぎるので、日本語訳をしてみる。
当翻訳文書上の注意  著作権は原文書に帰属します。 訳者の注についてはカッコ付き斜体で_（訳注：このように）_表記します。 意図的・偶発的問わずtypoについては本来の語を推定し、その箇所には訳注を入れています。 英語力が低いので、あちこち誤訳がありそうです。編集リクエスト待ってます。  以下訳文 JSON Schema：JSONドキュメント定義のためのメディアタイプ 概要 JSON Schemaは、JSONデータの構造を記述するための application/schema+jsonメディアタイプ を定義します。JSON Schemaの記述自体もJSONで形式で行われます。 JSON Schemaは、JSONドキュメントがどのように見えるか、情報をどのように抽出すればよいか、そしてその情報をどのようにやりとりするかを宣言します。他にハイパーメディアコントロールや機械的可読性を持たない、既存のAPIに注釈をつけるのに理想的です。
読者への注意 このドラフトのIssueリストは &amp;lt;https://github.com/json-schema-org/json-schema-spec/issues&amp;gt; にあります。 追加情報については &amp;lt;http://json-schema.org&amp;gt; を参照してください。 フィードバックは前述のIssueリスト、ホームページに記載された連絡先、または著者にメールでお知らせください。
この文書のステータス このInternet Draftは、BCP78およびBCP79の規定に完全に準拠して提出されています。
インターネットドラフトは、インターネットエンジニアリングタスクフォース（IETF）の作業文書です。他のグループがインターネットドラフトとして作業文書を配布することもできることに注意してください。現在のインターネットドラフトのリストはhttp://datatracker.ietf.org/drafts/current/にあります。
インターネットドラフトは、最大6か月間有効なドラフト文書であり、いつでも他の文書によって更新、置き換え、または廃止される可能性があります。参考資料としてインターネットドラフトを使用したり、「進行中の作業」以外のものを引用することは不適切です。
このインターネットドラフトは2017年4月16日に期限切れになります。
著作権 （訳注：略。原文参照のこと）
目次 （訳注：略。Qiitaの目次機能利用のこと）
1. はじめに JSON Schemaは、JSONデータの構造を定義するためのJSONメディアタイプです。JSON Schemaは、JSONデータのバリデーション、ドキュメンテーション、ハイパーリンクのナビゲーション、相互作用の制御を定義することを目的としています。
この仕様では、JSON referenceによる外部JSON Schemaへの参照と参照解決 （訳注：dereferencing） 、JSON Schemaで使用される vocabulary の明確化、および schema に対するインスタンスの処理に必要な最小機能の宣言といった、JSON Schema Coreの用語とメカニズムを定義しています。
バリデーション、リンク、アノテーション、ナビゲーション、相互作用に関する宣言のための vocabulary は、他の仕様で記述しています。
2.表記と用語 この文書内の&amp;rdquo;MUST&amp;rdquo; &amp;ldquo;MUST NOT&amp;rdquo; &amp;ldquo;REQUIRED&amp;rdquo; &amp;ldquo;SHALL&amp;rdquo; &amp;ldquo;SHALL NOT&amp;rdquo; &amp;ldquo;SHOULD&amp;rdquo; &amp;ldquo;SHOULD NOT&amp;rdquo; &amp;ldquo;RECOMMENDED&amp;rdquo; &amp;ldquo;MAY&amp;rdquo; &amp;ldquo;OPTIONAL&amp;rdquo;といったキーワードは、RFC 2119に沿って解釈しなくてはなりません。</description>
    </item>
    
    <item>
      <title>go testの出力を見やすくするツール作ったった</title>
      <link>https://kyoh86.work/posts/2017-01-15_01-15-03/</link>
      <pubDate>Sun, 15 Jan 2017 01:15:03 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2017-01-15_01-15-03/</guid>
      <description>go test してますか。 標準テストライブラリの出力を見やすくするツール richgo を作ったので、紹介をば。
TL;DR Goには公式でリッチなテストフレームワークがないですね。 思想[1][2]は好きなんですが、とはいえ出力の見づらさはなんとかならんものか・・・。 あまりにも見づらいので、go をラップして、 test の出力を無理やり色付けするツールを作りました。
richgo
使うと、こんな感じになります。 
インストール方法 おなじみ go get
go get -u github.com/kyoh86/richgo  使い方 richgo test ./...  他の機能を阻害することはないので go のエイリアスとしてしまうのがおすすめです。
alias go=richgo go test ./...  スタイルの設定変更 設定ファイルでスタイルを変えることもできます。 実行時に、次の順番で設定ファイルを読む仕様になっています。
 ${CWD}/.richstyle ${CWD}/.richstyle.yaml ${CWD}/.richstyle.yml ${GOPATH}/.richstyle ${GOPATH}/.richstyle.yaml ${GOPATH}/.richstyle.yml ${GOROOT}/.richstyle ${GOROOT}/.richstyle.yaml ${GOROOT}/.richstyle.yml ${HOME}/.richstyle ${HOME}/.richstyle.yaml ${HOME}/.richstyle.yml  環境変数に RICHGO_LOCAL=1 とすれば、カレントディレクトリの設定ファイル（${CWD}/.richstyle*）だけを読み込むようになります。
設定ファイルのフォーマット 設定は、YAML形式で次のような形で記載します。 すべての項目は、設定しなければデフォルト／または先に読み込んだ設定ファイルの内容が反映されます。
# ラベルの見せ方 labelType: (long | short | none) # ビルドログの見た目 buildStyle: # 出力しない hide: (true | false) # 太字 bold: (true | false) # 淡い字、または細い字 faint: (true | false) # 斜体 italic: (true | false) # アンダーライン underline: (true | false) # 点滅（ゆっくり） blinkSlow: (true | false) # 点滅（はやい） blinkRapid: (true | false) # 前景色と背景色を入れ替える inverse: (true | false) # 前景色と背景色を同色にする conceal: (true | false) # 取り消し線を引く crossOut: (true | false) frame: (true | false) encircle: (true | false) # アッパーライン overline: (true | false) # 文字前景色 foreground: (#xxxxxx | rgb(0-256,0-256,0-256) | rgb(0x00-0xFF,0x00-0xFF,0x00-0xFF) | (name of colors)) # 文字背景色 background: # Same format as `foreground` # テスト開始ログの見た目 startStyle: # Same format as `buildStyle` # テスト通過ログの見た目 passStyle: # Same format as `buildStyle` # テスト失敗ログの見た目 failStyle: # Same format as `buildStyle` # テストスキップログの見た目 skipStyle: # Same format as `buildStyle` # テスト対象ファイル名の見た目 fileStyle: # Same format as `buildStyle` # エラーログ行番号の見た目 lineStyle: # Same format as `buildStyle` # 行ごと出力したくない行を、正規表現で指定 removals: - (regexp)  ログの種類 設定ファイルのフォーマットに書いたように、 richgo はテストの出力を一行ごとにカテゴライズして、 それぞれに独自のスタイルを設定しています。</description>
    </item>
    
    <item>
      <title>【メモ】作りたいモノリスト</title>
      <link>https://kyoh86.work/posts/2016-12-12_12-25-45/</link>
      <pubDate>Mon, 12 Dec 2016 12:25:45 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2016-12-12_12-25-45/</guid>
      <description>誰か作ってくれないかなぁ、でも最近、何も作ってないし何か作りたいなあと思っているもののリスト。 随時更新予定。
ATOM-fuzzy-finderをまともにする  .atomignoreとか、agignore対応とか。genコード無視とかリポジトリごとの都合ってもんがあるべや。 AHOのように重すぎる。git ls-fileを使った高速化とかできるんじゃないの（雑）  colorgoをまともにする  https://github.com/songgao/colorgo t.Runとかでサブに入った時カラーリングされない。雑か FAILとかこそ色つけろよ的な。雑か  ATOM-Go-guru Goggles is written &amp;ldquo;ゴーグル&amp;rdquo; [goːgɯɽɯ] in katakana, so Go-guru is.
いい加減guru誰か頑張れよと思いつつ楽しそうなので作る
ATOM-Japanesque-theme Japanesque
ふつくしい。 コーディングにも適用して使いやすい・見やすいかは未知数</description>
    </item>
    
    <item>
      <title>zshの便利設定2016</title>
      <link>https://kyoh86.work/posts/2016-12-12_00-52-12/</link>
      <pubDate>Mon, 12 Dec 2016 00:52:12 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2016-12-12_00-52-12/</guid>
      <description>こんばんわ。WACULのプログラマー、 @kyoh86 です。 このエントリはWACUL Advent Calendar 2016の12日目の記事です。
年末といえば大掃除ですね。 押入れ、トイレ、玄関、換気扇…普段あまり凝って手を入れないところも、キレイにしていくものです。 そう、例えば .zshrc とか。え？やらない？それではいい年は迎えられないでしょうね。
ソースで語れよ https://github.com/kyoh86/dotfiles
はい。
ゴッチャゴチャなので、個人的整理も兼ねて記事にしちゃいます。 決して当日になってネタが無くて焦っているわけではありません。
はじめに：fzfありがとう fzfほんと便利。pecoより、色々機能が強くて便利。 とはいえ強い機能は殆ど使いこなせてないんですが…。
zsh神（勝手に崇めてる）こと @b4b4r07 さんも記事を書いてますね。
http://qiita.com/b4b4r07/items/9e1bbffb1be70b6ce033
リポジトリ選んでcdしちゃう君 https://github.com/kyoh86/dotfiles/blob/master/function/cd-ghq-repository
ローカルのリポジトリが増えてくると、ディレクトリ選んで cd するのも大変なので、特定のパスルールに則っておいて、リポジトリセレクタのように fzf で移動できるととても便利です。
command ls -d $GOPATH/src/github.com/{wacul,wcl48,kyoh86}/*(N-/) \ | fzf &amp;quot;$GOPATH/src/github.com/&amp;quot; \ | anyframe-action-execute cd --  僕は普段 golang 使いなので、 ${GOPATH} 配下の特定パスルールで ls -d hoge/*(N-/) してしまって、あとは fzf で絞り込んでいます。 ghq list なんかも悪くは無いんですが、いかんせんthird-partyのリポジトリと自分のリポジトリを分けて管理するのが面倒くさいのと、単純に毎回.git探してしまうのは些か重すぎるので、lsで簡略しています。
anyframe-action-execute は、fzf/pecoの薄いラッパーanyframe の1機能です。fzfからパイプして何も考えずにcallできるので、使っています。 こちらも作者のzsh神（勝手に拝んでる）こと @mollifier さんが詳細を記事にしてくださってます。
http://qiita.com/mollifier/items/81b18c012d7841ab33c3
launchctlのサービス名検索する君 https://github.com/kyoh86/dotfiles/blob/master/function/insert-launchctl
Macだと、launchctlで色々なデーモン・サービスを起動、終了するシーンがあるかとおもいます。が、あのlaunchctlの長いサービス名を覚えられないことが多々。</description>
    </item>
    
    <item>
      <title>GitHubで自動生成コードをDiffに表示しない方法</title>
      <link>https://kyoh86.work/posts/2016-12-07_03-06-32/</link>
      <pubDate>Wed, 07 Dec 2016 03:06:32 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2016-12-07_03-06-32/</guid>
      <description>結論 ここに書いてある
https://github.com/github/linguist/blob/master/lib/linguist/generated.rb
注意事項 だいぶ懐かしい記事ですが…突然、「Diffに表示しないなんてGitHubの価値を損なうものだから記事を非公開にするべきだ」というご指摘をいただいたので、念のため追記。
Diffに表示しない、ってことは当然PRにも見えません。 レビューされない怪しいコードが紛れ込むリスクを抱えることになります。 せいぜい自動生成分だけを非表示にして、CIの中で再生成、差分が出ないチェックを入れるなど、ガードの手は考えておいたほうが良いでしょうね。はい。ご利用は計画的に。
背景 mockeryだったり、swagger-codegenだったり、go-bindataだったり… GitHub上に自動生成されたコードを載せている場合、PRやcommitの詳細画面でDiffが邪魔になることがあります。
 .gitignoreでそもそも自動生成コードをリポジトリに載せない generatedコードに冪等性を持たせてDiffを最小限にする  など対策は色々ありますが、 どうしても生成分をリポジトリに載せたいがGitHub上ではdiffとして見えなくていい 場合もあります。
今までさんざん色々探したんですが、いい対策方法が見つからず・・・ ところがどっこい、GitHub公式の方法で実現できたので記事にしてみました。
GitHubのdiffで特定のファイルを隠す方法 そんなときは、例えばgoの場合はファイルの先頭に
// Code generated by xxx :  と一行コメントしてやるだけで、Diffに表示されなくなります。
https://github.com/kyoh86/qiita/commit/1e151528d570c3613b478245d88aeb168ead2874
その他の言語でも 色々な言語で対応しているようです。 判定方法はrbのソースを見ればひと通りわかりそう…。
https://github.com/github/linguist/blob/master/lib/linguist/generated.rb
いつからできたんだろう？ 結構探したんですが、GitHubのドキュメントやリリースノートも見つけられてません。 そんなん常識だが、とかここで書かれてたやん、みたいな話があったら教えてくれると嬉しいです。</description>
    </item>
    
    <item>
      <title>ズボラな僕らだからこそ「正しそうで正しくない少し正しいgitの使い方」</title>
      <link>https://kyoh86.work/posts/2016-12-02_00-01-28/</link>
      <pubDate>Fri, 02 Dec 2016 00:01:28 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2016-12-02_00-01-28/</guid>
      <description>本日のいまさら記事はこちらです。
この記事の対象読者 commit messageは wip fix が9割を超える 「宇宙人」と書いて「マメな人」と読む 夏休みの宿題を9/1までに終える人は未来人である 「毎日1分頑張るだけ」などと言える超能力者がいるらしい   ただの人間にしか興味ありません。 この中に宇宙人、未来人、異世界人、超能力者がいたら、そっと記事を「いいね」して閉じなさい。以上！
 コミットの正しい運用って？ 色んな世界線の人が参考になる記事を書いています。
http://qiita.com/kozyty@github/items/87fa95a236b6142f7c10 http://qiita.com/itosho/items/9565c6ad2ffc24c09364 http://qiita.com/risacan/items/f4cbabc62b684ab9296d http://qiita.com/crifff/items/1abf08bca4ce51db4775
などなど。
正しい世界の人はこれらの記事を参考にしましょう。
正しいコミットを常に意識しろ、なんて面倒くさい。ならどうすればいい？ ズボラなコミットメッセージ、適当なプルリクエスト、File Changes(243) は嫌われます。 チームメンバーのMPを削っても、良いことはありません。
ですから、次の事だけは気を付けましょう。
みんなで作業するブランチは汚さない  自分だけのブランチで作業して、できあがったらPR！PR！！PR！！！ マージするときはGitHubのSquash and Mergeを使おう  人の目に触れるもの（≒プルリクエスト）はキレイにする  プルリクエストの description で何を目的とした変更なのか明確に説明する  ポエムにしない。 せめて新機能の追加なのか、バグフィクスなのか、リファクタリングなのかだけでも書く。  どこを重点的に見てほしいのか、小さな単位で説明する  もちろん「小さい変更・小さいPR」が良いけど、面倒くさい諸事情により大きくなることもある。 「●●ってファイルの✕✕行目、△△のためにこうしたけど、□□かもしれんので見て欲しい」   「●●ファイルの✕✕行目」って・・・もっとなんか良いのあるだろ！ はい。そこまで来て初めて、「コミットは小さくしよう、メッセージは適切に」という言葉が身にしみ得るんです。最近実感しました。
とはいえ、「あれやってる最中にここが気になってこっちも直した」は普通の人ならよくあることです。 実装中には面倒くさくて、「あ、コレ違う、別のブランチ切ろう、あの時点に戻ってここからブランチ切って・・・」なんて、面倒くさくてやってられません。面倒くさくて。
例えばSlackに投稿する前に、間違いがないか厳密に推敲するでしょうか？しませんよね。 とりあえずEnterキーをターン！で、後からEditすりゃいいですよね。あとで見えなきゃいいんです。
「あとでキレイにすればいいや」。 そもそもVersion管理をとても乱暴に言ってしまえば、「あとで何があったか見返すためのもの」「あとで過去の編集を改めるためのもの」です。 ですから、コミットなんて最初は適当でいいんです。 実装中は直したいところを直して、やりたい放題コミットしまくりましょう。
ただし、自分用の作業ブランチで。他人様に迷惑をかけることだけはやめましょう。
こんなふうに出来たらいいな  ●●の機能を追加するため、…
 ●●の実装: 9xd4941 ●●のテスト: 0979xd2 ついでにやった✕✕のリファクタリング: 337xab7 自動生成コード部分: 6exd364   見やすいですね。もっとキレイにすることはできるでしょうが…</description>
    </item>
    
    <item>
      <title>goのinterfaceのstub生成する君</title>
      <link>https://kyoh86.work/posts/2016-10-06_08-48-48/</link>
      <pubDate>Thu, 06 Oct 2016 08:48:48 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2016-10-06_08-48-48/</guid>
      <description>本題 ATOMのパッケージ作ったよ！（宣伝）
何のために？ GoでDIとかゴニョゴニョしてると、しばしばinterfaceの実装を書くシーンに直面しますが、 interfaceが大きく複雑になってくるとだいぶつらたんですよね。
大きいinterfaceを書くな、小さいinterfaceの組み合わせにしろ、って話は踏まえてもやっぱり辛いんじゃないかなと。
なので、interfaceを指定したらば実装のスタブを自動で生成して、スニペットのように貼り付けられるパッケージを作ってみました。
何ができるの？ 1. スタブの生成 コマンドパレットからGo Impl: Find Declaration、またはキーバインドctrl-iで、カーソルの当たっているinterfaceから、スタブを生成できます。
2. スタブの貼付け コマンドパレットからGo Impl: Put Declaration、またはキーバインドctrl-shift-iで、カーソル位置に最後に生成したスタブをスニペットのように貼り付けられます。 貼り付けると自動で各メソッドのレシーバを選択した状態になるので、そのままレシーバを書き換えられます。
3. 履歴から選んで貼付け コマンドパレットからGo Impl: Toggle、またはキーバインドctrl-alt-iで、生成されたスタブの履歴から選択して、スニペットのように貼り付けられます。
改善点 ゴミが残る危険性 動画内だと、さも当然のようにstruct内にinterfaceを埋め込み表記してますが、これ自体にinterfaceを実装するという宣言のような意味はありません。golangのinterface実装はダックタイピングですし。 言語仕様通り「埋め込まれる」だけなので、邪魔にしかなりません。ゴミです。消しましょう。
ソース中にゴミを（一時的とは言え）置かざるを得ない実装は少々不本意です。
だのでGo Impl: Toggleでは、履歴を検索するだけでなく、入力された値からそのままinterfaceを検索して、スタブを生成する機能を付け加えたいところです。
少しばかり重い さらに言えば、すべてのinterfaceを内部でキャッシュしているわけではないので、毎度gopath以下を検索しています。 これは使用しているImplにおける制約ですが、こちらもなんとかしたいところ。 autocomplete-goの持ってる内部キャッシュなど上手いこと掠め取流用すれば、ある程度平易に実装できる気がしています。</description>
    </item>
    
    <item>
      <title>【メモ】Node.js? io.js? なんのことです？</title>
      <link>https://kyoh86.work/posts/2016-10-06_08-12-34/</link>
      <pubDate>Thu, 06 Oct 2016 08:12:34 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2016-10-06_08-12-34/</guid>
      <description> （勝手に）割と衝撃を受けたのでメモ。
元ネタ 知らないうちにMacがシステム標準でJavaScriptで操作できるようになってた (JXA) GoでOSXのアプリを書く #golang
OSXなら、別にNode動かさんでもJavaScriptでそこそこのことができる。
#!/usr/bin/osascript -l JavaScript console.log(&amp;quot;baz&amp;quot;);  こんな感じで書いて、適当なファイル名で保存して、chmod +x foobarで実行権限与えとけば、foobarで実行できる。 所謂AppleScriptのエンジンがJavaScriptも解する様になったことで、いい感じにやってくれてる。 Yosemiteからだよ〜とか、もうそれ１年前の話やよ〜、って事実にも衝撃を受けてる。
もちろん、Node.jsは標準ライブラリの強力さが魅力の一つだし、これで何かやろうと思うのは割と苦行だと思うが、逆にNode.jsだとOSXのAPI叩くのつらたんだし、簡単なスクリプトをシェルじゃなくてJavaScriptで書けるとしたらそこそこ嬉しいんじゃないかななんて。 Golangで〜のエントリはネタとしても（ネタですよね？）、golangなりなんなりOSXのAPIとは縁遠い言語とのグルーとして使えば結構クールなんじゃないかなぁなんて。
あ、全然？ですよねー。
でもこれ、tsd書いてtypescript -&amp;gt; (webpack) -&amp;gt; osascript ‥いや、辞めておこう
幻 え？WindowsならJScriptがある？VBScript？ </description>
    </item>
    
    <item>
      <title>ECS上のgo製プログラムのプロファイル覗き見る</title>
      <link>https://kyoh86.work/posts/2016-09-14_15-42-22/</link>
      <pubDate>Wed, 14 Sep 2016 15:42:22 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2016-09-14_15-42-22/</guid>
      <description> SSHトンネリングに必要な情報を得るための手順が多くて忘れるのでメモ。 うっかりsudo忘れる。
前提 goのpprofについては
 http://blog.livedoor.jp/sonots/archives/39879160.html  とか
 http://qiita.com/ikawaha/items/e3b35f09fb49e9217924  とか参照。 当然profiler動いてなきゃ話にならんので注意。
トンネリング  ECSのタスク選ぶ instanceのIP見る sshで入ってsudo su - docker psで、対象サービスのコンテナ探してIDを確認
$ docker ps -f name=api-server --format=&amp;quot;{{.ID}}&amp;quot; 123a456b78  docker inspectで、対象コンテナIDからコンテナのIPアドレス取得
$ docker inspect --format=&amp;quot;{{ .NetworkSettings.IPAddress }}&amp;quot; 123a456b78 172.17.0.1  ssh抜ける
 localhostの適当なポートに、指定インスタンス経由でコンテナのプロファイラのポートをトンネリングさせる
# ssh &amp;lt;instanceIP&amp;gt; -L &amp;lt;port&amp;gt;:&amp;lt;container IP&amp;gt;:&amp;lt;prof port&amp;gt; $ ssh 56.64.122.32 -L 9999:172.17.0.1:33680   プロファイラ見る go tool pprof localhost:9999/debug/pprof/profile  </description>
    </item>
    
    <item>
      <title>JSON to CSV (for Excel)</title>
      <link>https://kyoh86.work/posts/2016-06-03_11-11-54/</link>
      <pubDate>Fri, 03 Jun 2016 11:11:54 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2016-06-03_11-11-54/</guid>
      <description>CSV（Character-Separated Values）ってなんだかとってもアレですよね！ 某Excelの場合、Tab区切りのUTF-16LE with BOMじゃないと素直には開けなかったりするし。
JSON to CSV(TSV) ツールは色々あるけど、jq か csvkit がよさげ。
 jq -r &#39;(.[]|[.name,.age])|@tsv&#39; in2csv -fjson|csvformat -TU1&#39;  ただのCSVにするなら、in2csv -fjson だけでいい   utf-8 to utf-16LEBOM nkf または iconv
 nkf -W8 -w16L iconv -f UTF-8 -t UTF-16  繋げば・・・ csvkit×nkfの例：
cat hoge.json|in2csv -fjson|csvformat -TU1|nkf -W8 -w16L&amp;gt;hoge.csv&#39;
ってな感じ。
某M$ utf-8のCSV(Comma-Separated Values)をもっと素直に開けるように対応してくれないかなあ。</description>
    </item>
    
    <item>
      <title>Perl6でも愛が生まれた</title>
      <link>https://kyoh86.work/posts/2016-05-09_22-33-33/</link>
      <pubDate>Mon, 09 May 2016 22:33:33 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2016-05-09_22-33-33/</guid>
      <description> say &amp;quot;生&amp;quot;~&amp;amp;&amp;quot;死&amp;quot;  参考  愛が生まれた - Qiita なんで愛が生まれるのか - Qiita  </description>
    </item>
    
    <item>
      <title>PHP&#43;postfix with Gmail on El Capitan</title>
      <link>https://kyoh86.work/posts/2016-05-06_23-13-18/</link>
      <pubDate>Fri, 06 May 2016 23:13:18 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2016-05-06_23-13-18/</guid>
      <description>OSX上でphp -S localhost:8080なんぞして、mb_send_mailなアプリを作ってたんですが、メール送信テストしたくてもまーなかなか上手く行かないもので。やっとの思いで一通したのでここに眠らせる。R.I.P.
ベースとなった環境  OSX El Capitan 10.11.4 postfix (mail_version = 2.11.0) PHP 5.6.21 (cli) (built: Apr 29 2016 02:31:44)  これだけhomebrewによる。   用意する各種設定ファイル  postfix 設定ファイル  # : # : 前略 # : # CUSTOM ######## # Minimum Postfix-specific configurations. mail_owner = _postfix setgid_group = _postdrop myhostname = smtp.gmail.com relayhost=[smtp.gmail.com]:587 smtp_sasl_auth_enable = yes smtp_sasl_password_maps = hash:/etc/postfix/sasl_passwd smtp_sasl_tls_security_options = noanonymous smtp_use_tls = yes smtp_sasl_mechanism_filter = plain   postfix パスワードファイル (/etc/postfix/sasl_passwd)</description>
    </item>
    
    <item>
      <title>【メモ】mongoDBで環境間のデータに差異が無いか確認する方法</title>
      <link>https://kyoh86.work/posts/2016-04-13_13-10-56/</link>
      <pubDate>Wed, 13 Apr 2016 13:10:56 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2016-04-13_13-10-56/</guid>
      <description>動機 開発環境とリリース前確認用の環境で、MongoDBのデータに差異が無いか確認しようと思ったけど、 数十万件あるデータを比べるとか無理じゃね？と思った時に。
mongoexport使う mongoexportで出力して、ちょいちょいと整形してやればよろし。 クエリも投げられるので、対象データの絞り込みは容易。
一致するはず！と期待しているフィールドを選んで、--fields と --sort にそれぞれ指定してあげる。
mongoexport --host example.mongo --db hoge --collection piyo --query &#39;{userId:ObjectId(&amp;quot;xxxxx&amp;quot;)}&#39; --fields name,credit,zip --sort &#39;{name:1,credit:1,zip:1}&#39; --out hoge.json mongoexport --host example.mongo --db fuga --collection piyo --query &#39;{userId:ObjectId(&amp;quot;xxxxx&amp;quot;)}&#39; --fields name,credit,zip --sort &#39;{name:1,credit:1,zip:1}&#39; --out fuga.json  そんままでは_idが当然のように一致しないので、除去する。_idが無いなら気にしなくていい。
 cat hoge.json | perl -pe &#39;s/&amp;quot;_id&amp;quot; : \{ &amp;quot;\$oid&amp;quot; : &amp;quot;[a-f0-9]+&amp;quot; \}, //g&#39; &amp;gt; hoge-trim.json cat fuga.json | perl -pe &#39;s/&amp;quot;_id&amp;quot; : \{ &amp;quot;\$oid&amp;quot; : &amp;quot;[a-f0-9]+&amp;quot; \}, //g&#39; &amp;gt; fuga-trim.</description>
    </item>
    
    <item>
      <title>【メモ】【OSX】peco/fzf でブランチ切替</title>
      <link>https://kyoh86.work/posts/2016-04-06_11-07-31/</link>
      <pubDate>Wed, 06 Apr 2016 11:07:31 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2016-04-06_11-07-31/</guid>
      <description>git branch -a \ | perl -ne&#39;m|[^/\* ]+$|;next if$_{$&amp;amp;};$_{$&amp;amp;}=1;next if m,^\*|remotes/.+/HEAD,;$s=&amp;quot;\e[0m&amp;lt;S&amp;gt;&amp;quot;;s|.*/([^/]+)/|\e[31m$1$s|; s|^ +([^/]+)$|\e[34mlocal$s$1|;print&#39; \ | column -ts&#39;&amp;lt;S&amp;gt;&#39; \ | fzf --ansi \ | xargs git checkout  </description>
    </item>
    
    <item>
      <title>golintと闘いたいけど心の折れてしまった勇者のための隠しダンジョン</title>
      <link>https://kyoh86.work/posts/2016-02-09_01-21-41/</link>
      <pubDate>Tue, 09 Feb 2016 01:21:41 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2016-02-09_01-21-41/</guid>
      <description>結論 Pull-Request時にCIで差分lintかけるといい感じ。
背景 Goでの開発においては、型付け言語の利点を最大限に活かしたいところです。 go-vetやgolintを通していれば、潜在的バグに悩まされる確率を、劇的に下げることができる・・・実に素晴らしいですよね。
ですが、時にプロダクトの黎明期にあって、「こまいコト気にしてたらやってらんないから、とにかく作る！」と勢いに任せて作るのも大事なことだったりします。
しかしその結果、
 ふと気づけばソースコードの総量は10万行が見えてくる・・・ golint ./... を叩いてみれば、エラーが数千個・・・  なんてこともままあることでしょう。
それでも取り組むべき価値がある ですが、そんな時でも遅くはありません。 GitHubのPull-RequestとCIツールを組み合わせれば、
今まさに修正した場所に、golintで問題とされるような箇所がないか
をチェックすることができます。 数千のエラーといっぺんに闘うことは難しくても、一度のPRで数十のエラーと戦い続ければ、いずれエラーはゼロになっていくはずです。 そう、バグを潰す気持ちと何ら変わらない、シンプルな作業ゲーと化すことができるのです。
解決策 用意するものはgoghだけ1です。
owner= # 対象リポジトリ名（オーナー名）を設定 repos= # 対象リポジトリ名を設定 min_confidence=0.9 # 警告のレベル head=$(git rev-parse --abbrev-ref @) # 現在のブランチを取得 if [ -n &amp;quot;${head}&amp;quot; ] then # 現在のブランチをheadとするpull-requestを探す base=$(gogh pr ls --repo ${owner}/${repos} --head ${owner}:${head} --state open --row-format $&#39;{{.Base.Ref}}&#39;) if [ -z &amp;quot;${base}&amp;quot; ] then # pull-requestが見つからなければそのまま終了 echo &amp;quot;pull-request is not found&amp;quot; else # pull-requestのbaseブランチと、差分のあるファイルの一覧を取得 tmpfile=$(mktemp) git fetch origin ${base}:${base} git diff ${base}.</description>
    </item>
    
    <item>
      <title>Homebrewでインストールしたあいつらを丁寧にアップデートする</title>
      <link>https://kyoh86.work/posts/2016-02-08_14-34-13/</link>
      <pubDate>Mon, 08 Feb 2016 14:34:13 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2016-02-08_14-34-13/</guid>
      <description>【コメント頂いて書き直しました】
homebrew でパッケージの管理をするのはいいんですが、開発の都合上一部のツールのバージョンを上げられない・・・というシーンはままあるかと思います。 かといってoutdatedなパッケージを放置するのも気持ち悪いですよね。
そんな「brew upgradeで全てのパッケージをアップデートしたら色々死ぬわ！」という場合によく使うのでメモ書き。
$ brew update &amp;amp;&amp;amp; brew outdated # 更新が必要なパッケージの一覧を取得、確認。 ... ... $ brew outdated \ | awk &#39;{print $1}&#39; \ | grep -v &#39;elasticsearch&#39; \ | grep -v &#39;mongo&#39; \ | xargs -n 1 brew upgrade  brew outdatedで リスト化して、grep -v 1 でそっとしておいて欲しいパッケージ（例ではElasticsearchとMongo DB）を除外して、xargsでbrew upgrade。シンプル。 fzf とか peco とか駆使すれば、もっとホスピタリティの高い感じにできると思うけど、まァ良いかという気持ち。
 grepはcoreutils入れてる環境とか考えると、BSD/GNUの仕様誤差がめんどくさいので、grep -v &amp;lsquo;hoge&amp;rsquo;を二重にパイプしてます。 [return]   </description>
    </item>
    
    <item>
      <title>golangでellipsis</title>
      <link>https://kyoh86.work/posts/2016-02-01_11-05-36/</link>
      <pubDate>Mon, 01 Feb 2016 11:05:36 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2016-02-01_11-05-36/</guid>
      <description>Goで文字の省略処理（Ellipsis）しようとしたら、初歩的なことで躓いたのでメモ程度に。
結論 package main // Ellipsis a text func Ellipsis(length int, text string) string { r := []rune(text) if len(r) &amp;gt; length { return string(r[0:length]) + &amp;quot;...&amp;quot; } return text }  要点  len(string)は鬼門  バイト数返す。考えてみたら当然だよね☆  string[n:m]は鬼門  バイト位置で切る。考えてみたら当ｚ   蛇足 string 系の関数作るときは、func(params..., string)の形に作るとちょっとだけ便利。
text/templateのFuncMapにそのまま放り込めたりする。些細だなー！
package main import ( &amp;quot;bytes&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;text/template&amp;quot; ) func main() { var buf bytes.Buffer template.New(&amp;quot;text&amp;quot;). Funcs(template.FuncMap{&amp;quot;ellipsis&amp;quot;: Ellipse}). Parse(`{{.value | ellipsis 5}}`). Execute(buf, map[string]string{&amp;quot;value&amp;quot;: &amp;quot;みんみんみらくる☆&amp;quot;}) fmt.</description>
    </item>
    
    <item>
      <title>Homebrewでインストールしまくったあいつらの正体を知りに行く</title>
      <link>https://kyoh86.work/posts/2016-01-09_09-44-27/</link>
      <pubDate>Sat, 09 Jan 2016 09:44:27 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2016-01-09_09-44-27/</guid>
      <description>結論 brew list | grep -v &#39;^lib&#39; | while read line; do echo -n ${line}$&#39;\t&#39; brew info $line | grep -P &#39;^https?://&#39; | head -n1 done | column -t -s $&#39;\t&#39; &amp;gt; brew-list.txt  atk https://library.gnome.org/devel/atk/ autoconf https://www.gnu.org/software/autoconf automake https://www.gnu.org/software/automake/ autotrace http://autotrace.sourceforge.net awscli https://aws.amazon.com/cli/ :  そこそこ便利。
背景 Homebrewは、OSX界じゃあデファクトスタンダードといった趣です。
ただ、最近 zplug でzsh上にplugin commandとして放り込んだほうが良いものも多々あるなァ、brewで何インストールしたっけな、とbrew listしたら絶望的な気持ちになりました。
あらあらまぁまぁ。
最初は「見覚えあるなァ、こいつ」と思ったものにアタリを付けて、検索して調べて・・・とやってましたが、正直やってられません。
brew info [formula] とすれば、各インストールの詳細も見れます。
が、 詳細ったって・・・なァ・・・。
こういう時こそ軽めのシェル芸だな、と思ったので飛び出しましたるのが冒頭のシェルです。
fzf なり、 peco なりと組み合わせてもいいかも。
brew list | grep -v &#39;^lib&#39; | while read line; do echo -n ${line}$&#39;\t&#39; brew info $line | grep -P &#39;^https?</description>
    </item>
    
    <item>
      <title>go で AggregationException(.NET)的なことをする</title>
      <link>https://kyoh86.work/posts/2015-12-24_10-53-07/</link>
      <pubDate>Thu, 24 Dec 2015 10:53:07 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2015-12-24_10-53-07/</guid>
      <description>おはようございます。皆さん、せい・・聖夜は如何お過ごしの予定でしょうか。
さてさて、Goのエラー処理についてはやいやい言われていますね。 エラートラップ忘れだの、エラーをどういうふうに伝播するべきか、といった記事がたくさんあります。侃々諤々といった感じで良いですね。
でも、意外と「ループの中で、エラーが発生しても無視して次に進めるが、発生したエラーを最後にまとめて回収する」みたいな話がなかったので、書いてみようと思います。 無いのは需要が無い（または自明過ぎて誰も書かない）からだ！と言われないうちに書ききってしまいましょう。
https://github.com/kyoh86/qiita
package util import ( &amp;quot;encoding/json&amp;quot; &amp;quot;errors&amp;quot; &amp;quot;fmt&amp;quot; ) // Errors : 複数のエラーを一括するエラー type Errors []error // Push : エラーを追加する func (a *Errors) Push(item error) { if item == nil { return } if arr, ok := item.(Errors); ok &amp;amp;&amp;amp; arr != nil { for _, child := range arr { a.Push(child) } } else { *a = append(*a, item) } } // IsEmpty : エラーが空かどうか取得する func (a *Errors) IsEmpty() bool { return a == nil || len(*a) == 0 } // Error : エラー出力を得る func (a Errors) Error() string { array := make([]string, len(a)) for i, item := range a { array[i] = item.</description>
    </item>
    
    <item>
      <title>gopkg.in絡みで困ることになる・・・のかもしれない？？</title>
      <link>https://kyoh86.work/posts/2015-12-18_17-55-22/</link>
      <pubDate>Fri, 18 Dec 2015 17:55:22 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2015-12-18_17-55-22/</guid>
      <description>gopkg.in便利ね gopkg.in便利なんですが、何かのトラブルの種になっている気配があるので起稿。
詳細については未調査につき、何らかの他の要因によるかもしれません
事象1: version違いのimport package A import &amp;quot;gopkg.in/foo/bar.v2&amp;quot;  package B import &amp;quot;gopkg.in/foo/bar.v1&amp;quot;  みたいなことが起きる。
 最初は&amp;quot;gopkg.in/foo/bar.v1&amp;quot;で開発していた 開発メンバーはあまり意識せずgo get ./...で関連パッケージ&amp;quot;gopkg.in/foo/bar.v1&amp;quot;を手に入れている。 途中で&amp;quot;gopkg.in/foo/bar.v2&amp;quot;を使うように更新した。 誰かが、A/alpha.go をコピーして、B/bravo.goを作ろう！と考える。 B/bravo.goを保存したタイミングで、goimportが走ってimport先が自動で&amp;quot;gopkg.in/foo/bar.v1&amp;quot;になってしまう。  事象2: CIが怒り出す。 「&amp;rdquo;github.com/hoge/piyo.xXXXX&amp;rdquo;なんて無いんですけど！」と怒られる。 一見、事象1のパッケージとは関係なさそうなところで起きる。 $GOPATH/src/github.com/hoge/piyo を見に行くけど、問題なさそう。 go get ./... とすると、やっぱり「&amp;rdquo;github.com/hoge/piyo.xXXXX&amp;rdquo;なんて無いんですけど！」と怒られる。
先述の事象1の状態を解消（B/bravo.goのimportを&amp;quot;gopkg.in/foo/bar.v2&amp;quot;に更新）したら、直った。
原因は調査中。 原因の根幹は未解明。
gopkgのバージョン番号がv1,v2という風に昇順な上に、goimportが若い番号のものを自動で割り当ててしまうことに原因がある・・・のかも。 同名のpackageが、違うURLで存在する場合に何らかの問題が起きる？？？
とりあえず一旦記事に起こしておく。</description>
    </item>
    
    <item>
      <title>GitHubのPullRequest一覧イマイチ使いづらくね？→捗るツール作ったった</title>
      <link>https://kyoh86.work/posts/2015-12-17_00-03-03/</link>
      <pubDate>Thu, 17 Dec 2015 00:03:03 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2015-12-17_00-03-03/</guid>
      <description>tl;dr Require status checks to pass before merging to master デプロイはjenkinsおじさんをひっぱたくだけのかんたんなお仕事 デプロイするときに、_このデプロイで何が変わるのか_を把握しておきたい masterブランチのpull-requestの履歴見りゃいいじゃん Yuck!  GitHub をCLIでいい感じにするツールを作ろう! Its&amp;rsquo; GOGH $ go get github.com/kyoh86/gogh $ gogh pull-request list --owner github --repos hub --sort closed --direction desc #1044	commands/fork: handle missing &amp;amp;#34;origin&amp;amp;#34; remote	master	12-04 05:09	12-08 18:26	12-08 18:26 #1038	Alter fork behavior to rename &amp;amp;#34;origin&amp;amp;#34; to &amp;amp;#34;upstream&amp;amp;#34;.	master	11-28 07:03	-	11-30 21:36 #961	client.Releases() fetches all pages.	master	07-18 09:07	-	11-26 10:46 #1031	Update redirects in Readme	master	11-15 01:04	-	11-16 20:06 #1024	Cache result of `git rev-parse --git-dir`	master	11-01 02:09	11-04 19:19	11-04 19:19  え？整形したい？columnにpipeしましょ。</description>
    </item>
    
    <item>
      <title>簡易リバースプロキシ「ichigo」でWebアプリ開発が捗る話</title>
      <link>https://kyoh86.work/posts/2015-12-07_02-30-43/</link>
      <pubDate>Mon, 07 Dec 2015 02:30:43 +0900</pubDate>
      
      <guid>https://kyoh86.work/posts/2015-12-07_02-30-43/</guid>
      <description>概要 自社サービスの開発中、必要にかられてGOで簡単なリバースプロキシツールを作った話を書いてみます。
前提 自社サービスの開発を、次のような構成で進めています。
 フロントエンドとバックエンド（APIなど）をパスで振り分け  /の下はフロントエンド /api/の下はAPI その他にも色々・・・  フロントエンドとバックエンドは、担当者もリポジトリも、動いているサーバも別 それぞれサーバが開発環境、本番環境とテスト環境、のように複数の環境をもっている  やりたいこと 前提の環境をもって、いざ開発をしようとローカル環境を構築するとなれば、
 ローカルにnginxでリバースプロキシを立てて管理するのは面倒くさい ちょっとした環境の変更があると共有がいちいち面倒くさい フロントエンド担当者がわざわざバックエンドをcloneだのpullだの面倒くさい 環境間でテストするためにわざわざnginxの設定書き換えるのも面倒くさい  と、面倒くさいことばかりになりがちです。
そこで、簡単なプロキシツールを作って、
 ローカルには自分の担当するサーバ（とプロキシツール）だけが動いていればいい 接続先の環境を容易に切り替えられる  ようになったら便利だなァ、というのが動機です。
作ってみた これを手軽に実現できるよう、簡単なリバースプロキシツールを作ってみました。
Ichigo (GitHub) いちごです。美味しいですよね、いちご。
使い方 詳しい使い方は、GitHubのREADMEを御覧ください。 ここではかんたんな機能紹介まで。
 Ichigo経由でアクセスすると、画面左下にコントローラーが現れます。  各サーバーのプロキシ先を、コントローラで切り替えられます。   愚痴 開発中のあれこれ  この程度のツールを作るなら、Goってホント良い感じ。  Goっていい感じ。  世の中にありそうなもんだけどなァ、と思ったらなかなかなかった。  もっと賢いやり方あったら教えてほしい  TypeScriptで頑張ってみたけど、やっぱりフロントエンド苦手。  でもやっぱりTypeScript最高。型付き言語最高。愛してる。（異論は認めます）  Goっていい感じ。 gorilla/muxとか、mux系は色々なライブラリがあるのに、もそっと柔らかいライブラリはないものなのか・・・。  /*はこっち、/api/*はあっち、とかやろうとすると、全部/*に吸い取られる罠 net/http/httputil.ReverseProxy最高！  Goっていい感じ。  Goっていい感じ。 Gopher君ぺろぺろしたい   Thanks ちょっとした面倒を避けて、みんなの苺が美味しくなりますように</description>
    </item>
    
  </channel>
</rss>